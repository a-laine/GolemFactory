__/\\\\\\\\\\\\\\\_______/\\\\\_______/\\\\\\\\\\\\__________/\\\\\______        
 _\///////\\\/////______/\\\///\\\____\/\\\////////\\\______/\\\///\\\____       
  _______\/\\\_________/\\\/__\///\\\__\/\\\______\//\\\___/\\\/__\///\\\__      
   _______\/\\\________/\\\______\//\\\_\/\\\_______\/\\\__/\\\______\//\\\_     
    _______\/\\\_______\/\\\_______\/\\\_\/\\\_______\/\\\_\/\\\_______\/\\\_    
     _______\/\\\_______\//\\\______/\\\__\/\\\_______\/\\\_\//\\\______/\\\__   
      _______\/\\\________\///\\\__/\\\____\/\\\_______/\\\___\///\\\__/\\\____  
       _______\/\\\__________\///\\\\\/_____\/\\\\\\\\\\\\/______\///\\\\\/_____ 
        _______\///_____________\/////_______\////////////__________\/////_______

01000100 01101111 00100000 01101001 01110100 00100000 01110110 01100101
01110010 01111001 00100000 01110111 01100101 01101100 01101100 00100000
01101111 01110010 00100000 01100100 01101111 01101110 00100111 01110100
00100000 01100100 01101111 00100000 01101001 01110100 00100000 00100001


LITTLE TODO
Shader, font passer c++11



Scene manager:
	* change NodeVirtual* sons[] container list into a thread safe forward list.
	* add an optional NodeVirtual* adoptedSons[] thread safe forward list for optionnal sub tree.
	* add the map structure to populate a huge map with several tree just around the camera.
	* add support to change depth of these tree, depending on camera position
	* change this class to make it totaly thread safe !
	* add support of instance hierarchy :
	  two way possible :
		- getInstance function only return parent (and the renderer has to get child by himself)
		- getInstance function return parent and children with all instance have an absolute position/orientation
		  (so the renderer don't have to compute them)

Instance manager :
	* add support of instance hierarchy (parent <-> child)



ANIMATION MODULE (DESCRIPTION)

ResourceManager
	* a Skeleton struct or class, it's not a shared resource but a struct to define a skeleton
	  typicaly a list of vector and/or quaternion
	* a Pose struct or class, to define a Skeleton pose
	  typicaly a list of angles for all joint of the skeleton
	  a joint can be defined as irrelevant in a pose (useful for pose blending)
	* add a resource SkeletonAnimation from parsing a json file
	  this file specify a poses list. A pose is a list of position for all joint of the skeleton.
	  an animation can be defined as looped. if yes when the animation reach the end she loop on itself (useful for walking, running ...)
	  an animation can be defined as flaged. if yes a flags will be set up when the animation end

=> this define the "Action state machine" described in game architecture (this holly bible book!) p604
   the blend part is performed later in InstanceAnimatable class.
   all state machine are simple string or string looped on themself.

Animation manager:

=> for more  information all function described here define the "animation pinepline" described in game architecture p604

	* add a class InstanceAnimatable to add animation support to instances
	  an InstanceAnimatable is defined by :
		- a special configuration byte for animation state
		- a refresh rate
		- a vector<SkeletonAnimation*> animationList.
		  this list is for example: walking, running, dancing, sleeping, talking ...
		  one per action performable by the character
		  all SkeletonAnimation attached to this list have to be compatible (same number of joint, etc...)
		- a target pose of the skeleton (all target angles for the instance skeleton);
		- a virtual function int blend(int animationIndex, float speed)
			+ launch an animationat specific speed, if some joint are defined as irrevelant at some point of the animation, the joint keep the last animation launched on it.
			  so for example:
				at time 0 : the caracter launch the animation running -> all skeleton joint have targets angles from the running animation
				at time t1 : the carater launch the animation hold weapon -> all joint keep thee running animation state exept arms and hands joints.
			  this function is called by the Inteligence manager responsible for the caracter choises
			+ return a code corresponding of a "rate" of the blending operation performed.
		- an overload can be int blend(Pose specificSkeletonPose, float speed, bool flagedPose)
		- a virtual function bool animate(float elapsedTime), which perform several task :
			+ interpolate from the target pose and the current pose of the skeleton depending on joint speed, elapsedTime, ...
			+ if a joint target is reached, the next joint target is computed (just look the next step of the joint animation).
			+ if an animation finish and is defined as flaged, a flag is rised

	* design a base class for AnimationManager from a clearly defined task list
		- two function to add and remove InstanceAnimatable*
		- clasify all InstanceAnimatable* by group of refresh rate
		- one function for update all instances of a group
			+ example of behavour for this function:
				for each instance of the group to animate:
				{
					call the function animate(elapsedTime)
					call a function of the physics engine to correct the skeleton pose (depending on terrain, or environment for example)
					// in a ideal world it is in the physics engine that the instance position and speed are updated (depending on contact point with ground, etc...)
				}

=> for the "Animation controllers" described in book it's performed here by the InteligenceManager class (which regroup the behaviour of instances)

=> with this structure we can have:
	- standard animation such as dancing (all joints defined as revelant in the animation, animation defined as looped)
	- animation blending like shoot during running (because the target pose is defined via target joint and animation definition permit combination)
	- standard animation sequence such as seat down and just after drink a beer (seat down animation defined as flaged, when the flag is rised the InteligenceManager can launch a new animation: drink)
	- procedural animation such as climb a wall, or stairs (because the InteligenceManager can specify special pose directly: 
	  when a climbing hold is reached compute the next skeleton pose with a inverse kinematics module and blend it directly as flaged)
	- have crowd animation (each instance can have a refresh rate depending on its distance to camera)

















